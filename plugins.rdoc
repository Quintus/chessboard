= Plugins

Chessboard supports a plugin architecture for adding new features
developed by other people. This document covers how you can write your
own plugin and add it to Chessboard.

First note that Chessboard ships with a number of default plugins
already enabled; take a look at what’s inside your installations’s
plugin/ directory if you want to know more.

== Folder structure

In order for your new plugin to be recognized, it must reside in a
directory directly below the directory "plugins" in your Chessboard
installation. Inside this folder, there has to be a file called
"plugin.rb" which will be loaded during Chessboard’s startup sequence;
any other files you want to load have to be loaded manually by adding
+require+ statements or similar code to that file.

== Basic code setup

In your "plugin.rb" file you are required to define a module that
includes the Chessboard::Plugin module. How you name this module does
not matter, as long as you don’t name it +Chessboard+ in which case it
would conflict with Chessboard’s own namespace module. Also you
probably don’t want to name your module the same way another plugin
already has named it.

This then looks like this:

  module MyPlugin
    include Chessboard::Plugin
  end

With this code you created the absolute minimimum required for a
working plugin.

== Hooks

Such a mimimal plugin does not really help; it doesn’t do
anything. This is where _hooks_ come in. Hooks are predefined places
in Chessboard’s code where you can "hook" into in order to execute
your own code and provide your own behaviour. There exists for example
a "view_reply_post_content" hook that allows you to insert HTML below the
text area used for replying to posts, creating topics, etc. In order
to do so, you define the method +hook_view_reply_post_content+ like this:

  module MyPlugin
    include Chessboard::Plugin

    def hook_reply_post_content(options)
      prev = super
      prev + content_tag("p", "This is my extra content.")
    end

  end

There are some things to note here. First, the name of the hook method
you have to use is _always_ "hook_<name of hook>". This is the same
for all hooks. Next, hook methods always accept a single parameter
+options+. This is a hash that always contains at least the following
key-value entries:

[:request]
  Rack::Request object representing the current request.
[:session]
  Padrino::Session object representing the user’s session.
[:env]
  Rack::Environment object, used for transferring data along
  between requests. Most notably you have access too
    options[:env]["warden"]
  , which is the Warden authentifaction interface you can use
  to check if a user is logged in and which User instance
  corresponds to him.
[:flash]
  Padrino’s flash object.

Apart from these entries, there may be even more entries depending on
the hook. The +view_reply_post_content+ hook for example also adds an entry
:post that contains the Post instance being edited. These extra
entries are mentioned in the respective plugin’s documentation.

Hooks’ return values matter. For all the view hooks, the return value
is usually inserted into the page as-is. This means for you especially
that you have to call +html_safe+ on your string objects if you don’t
create them using Padrino’s ordinary helper methods (which are
available to you in your plugin, as could be seen with +content_tag+
above).

Note that all plugins are evaluated in order of inclusion (which you
usually can’t really predict) when a hook is executed. If you don’t
want to break the call chain (which you shouldn’t do), you should call
+super+ in your hook method as shown above and cope with the return
value of the previous hooks. View hooks will always return strings you
should append to, controller hooks usually use true/false to indicate
whether a record shall be saved or not. If this is not the case for a
specific hook, it will be mentioned in the documentation.

== Adding routes and pages

You can add new routes to the application with your plugin by
utilizing Padrino’s and Sinatra’s functionality. Use the following
structure:

  module YourPlugin
    include Chessboard::Plugin

    Chessboard::App.controllers :yourplugin do
      get :somepage, :map => "/somepage" do
        render :erb, "<p>Your ERuby markup</p>"
      end
    end
  end

Inside the +controllers+ block you can define any Padrino routes you
want. The controller name (+yourplugin+ in the above example) is
free-form, but choose one that is not already used by the application
itself (use <tt>rake routes</tt> to find those out) or by other
plugins. It is recommended to use your downcased and concatenated
plugin name.

With the above example, a new page <tt>/somepage</tt> will be
available in the application that renders the given ERuby markup with
ERB. Note that it will not automatically be linked somewhere; this
must be done manually. If you want to add it to the main menu at the
top for example, override the +hook_layout_navigation+ hook
accordingly.

== Storing additional data in the database

Chessboard makes use of ActiveRecord’s serialisers by adding an
attribute <tt>plugin_data</tt> to some classes (currently only
+Post+). This attribute holds a hash in which plugins can place their
own data. Please use the name of your plugin as they key, e.g.:

   mypost = Post.find(5)
   mypost.plugin_data[:MyPlugin] ||= {}
   mypost.plugin_data[:MyPlugin][:mykey] = "test data"
   mypost.save!
   # ...
   x = Post.find(5)
   p x.plugin_data[:MyPlugin] #=> {:mykey => "test data"}

The serialiser functionality uses YAML under the hood, so please do
not store objects in the plugin_data hash that cannot be serialised
with YAML (e.g. File instances and lambdas). This functionality is
quite a nice catch. Other forums require plugins to provide
migrations, with Chessboard you can just use a simple Ruby hash for
your data you want to attach.

== Padrino helpers

The Chessboard::Plugin class includes several of Padrino’s helper
modules. Look at its documentation to get an exhaustive list. This
enables you to mostly treat your plugin as if it was part of the main
application. For example, you can use the `deliver` helper method of
Padrino’s mailer functionality to deliver Chessboard’s core emails
(see the app/mailers directory for those).

== Reloading

Currently plugins aren’t reloaded automatically when you reload the
page. When you edit a plugin file and want the changes to take effect,
you have to restart the application server.

== Additional Gems

If your plugins needs additional gems, i.e. others than those already
listed in Chessboard’s main +Gemfile+, you can simply place another
+Gemfile+ in your plugins’s main directory (next to the +plugin.rb+
file). When the user uses <tt>bundle install</tt>, the additional
Gemfile will be detected and its Gems will be loaded. Note that as you
do not have the possibility to provide a +Gemfile.lock+, you might
want to be explicit about the version of the gem you require.

Do _not_ add a +source+ line to your plugin’s Gemfile. The +source+
has already been specified in Chessboard’s main Gemfile.

== Conclusion

That’s it basically. You can now have a look at the documentation of
Chessboard::Plugin, which lists all available hook methods (those
starting with "hook_").

If you want more examples on how to create plugins, look through the
set of default plugins that comes with Chessboard in your
installation’s "plugins" directory.
